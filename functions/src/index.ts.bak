/**
 * Firebase Functions (Gen-2) â€“ Maris Coin backend
 * - All user-facing messages are in English
 * - Region: europe-west1 (low latency for TR/EU)
 */

import * as admin from "firebase-admin";
import { logger } from "firebase-functions";
import { setGlobalOptions } from "firebase-functions/v2";
import { onCall } from "firebase-functions/v2/https";
import { onDocumentCreated } from "firebase-functions/v2/firestore";
import { onSchedule } from "firebase-functions/v2/scheduler";

// ---- Global options (applies to all v2 functions) ----
setGlobalOptions({
  region: "europe-west1",
  maxInstances: 10, // cost guard
  timeoutSeconds: 60,
  memory: "256MiB",
});

// ---- Admin SDK ----
if (!admin.apps.length) {
  admin.initializeApp();
}
const db = admin.firestore();

// ---- Helpers ----
async function getUserDoc(uid: string) {
  const ref = db.collection("users").doc(uid);
  const snap = await ref.get();
  return { ref, data: snap.data() ?? null };
}

async function findUserByReferralCode(code: string) {
  const q = await db
    .collection("users")
    .where("referralCode", "==", code)
    .limit(1)
    .get();
  if (q.empty) return null;
  const doc = q.docs[0];
  return { uid: doc.id, data: doc.data() };
}

// ======================================================
// 1) applyReferralCode (callable)
// ======================================================
export const applyReferralCode = onCall(async (request) => {
  const uid = request.auth?.uid;
  if (!uid) {
    throw new Error("You must be logged in to apply a referral code.");
  }

  const code = String(request.data?.code ?? "").trim();
  if (!code) {
    throw new Error("Please provide a valid referral code.");
  }

  const referrer = await findUserByReferralCode(code);
  if (!referrer) {
    throw new Error("Referral code not found.");
  }
  if (referrer.uid === uid) {
    throw new Error("You cannot use your own referral code.");
  }

  // Already linked with this referrer?
  const dup = await db
    .collection("invites")
    .where("referrerId", "==", referrer.uid)
    .where("inviteeId", "==", uid)
    .limit(1)
    .get();
  if (!dup.empty) {
    return { ok: true, info: "Invite already exists." };
  }

  // Invitee already used a code?
  const any = await db
    .collection("invites")
    .where("inviteeId", "==", uid)
    .limit(1)
    .get();
  if (!any.empty) {
    throw new Error("You have already linked a referral code.");
  }

  await db.runTransaction(async (tx) => {
    const referrerRef = db.collection("users").doc(referrer.uid);
    const inviteRef = db.collection("invites").doc();

    tx.set(inviteRef, {
      referrerId: referrer.uid,
      inviteeId: uid,
      status: "pending",
      joinedAt: admin.firestore.FieldValue.serverTimestamp(),
    });

    tx.update(referrerRef, {
      invitedCount: admin.firestore.FieldValue.increment(1),
    });
  });

  await db.collection("events").add({
    type: "invite.created",
    userId: uid,
    referrerId: referrer.uid,
    at: admin.firestore.FieldValue.serverTimestamp(),
  });

  logger.info("Referral code applied", { uid, referrer: referrer.uid });
  return { ok: true, message: "Referral code applied successfully." };
});

// ======================================================
// 2) onCheckInCreated (firestore trigger)
// path: checkins/{uid}/{month}/{day}
// ======================================================
export const onCheckInCreated = onDocumentCreated(
  "checkins/{uid}/{month}/{day}",
  async (event) => {
    const uid = event.params.uid as string;
    const month = event.params.month as string;
    const day = event.params.day as string;

    const user = await getUserDoc(uid);
    if (!user.data) return;

    const userRef = user.ref;
    const todayKey = `${month}-${day}`;
    const dayNum = parseInt(day, 10);
    const prevDay = String(dayNum - 1).padStart(2, "0");

    const prevDoc = await db.doc(`checkins/${uid}/${month}/${prevDay}`).get();
    const hasPrev = prevDoc.exists;

    await userRef.set(
      {
        lastCheckinKey: todayKey,
        streakDays: hasPrev
          ? admin.firestore.FieldValue.increment(1)
          : 1,
        points: admin.firestore.FieldValue.increment(10), // daily 10 pts
        updatedAt: admin.firestore.FieldValue.serverTimestamp(),
      },
      { merge: true }
    );

    await db.collection("events").add({
      type: "checkin",
      userId: uid,
      day: todayKey,
      at: admin.firestore.FieldValue.serverTimestamp(),
      points: 10,
    });

    logger.info("Daily check-in processed", { uid, todayKey });
  }
);

// ======================================================
// 3) computeActiveScore (callable)
// emailVerified + MFA + 7-day streak + task diversity (>=3 categories)
// ======================================================
export const computeActiveScore = onCall(async (request) => {
  const uid = request.auth?.uid;
  if (!uid) {
    throw new Error("You must be logged in to compute the active score.");
  }

  // Auth signals
  const authUser = await admin.auth().getUser(uid);
  const emailVerified = !!authUser.emailVerified;
  const hasMFA =
    (authUser.multiFactor?.enrolledFactors?.length ?? 0) > 0;

  // Streak signal
  const user = await getUserDoc(uid);
  const streak = Number(user.data?.streakDays ?? 0);
  const hasStreak7 = streak >= 7;

  // Task diversity signal
  let has3TaskTypes = false;
  const tSnap = await db
    .collection("users")
    .doc(uid)
    .collection("taskCompletions")
    .limit(200)
    .get();
  if (!tSnap.empty) {
    const cats = new Set<string>();
    tSnap.docs.forEach((d) => {
      const c = String(d.get("category") ?? "");
      if (c) cats.add(c);
    });
    has3TaskTypes = cats.size >= 3;
  }

  // Weights: MFA+Email (0.50) + Task diversity (0.25) + Streak7 (0.25)
  let score = 0;
  if (emailVerified && hasMFA) score += 0.5;
  if (has3TaskTypes) score += 0.25;
  if (hasStreak7) score += 0.25;

  const active = score >= 0.8;

  await user.ref.set(
    { activeScore: score, active, updatedAt: admin.firestore.FieldValue.serverTimestamp() },
    { merge: true }
  );

  // If newly active, flip pending invite and reward referrer
  if (active && !user.data?.active) {
    const invSnap = await db
      .collection("invites")
      .where("inviteeId", "==", uid)
      .where("status", "==", "pending")
      .limit(1)
      .get();

    if (!invSnap.empty) {
      const invDoc = invSnap.docs[0];
      const referrerId = String(invDoc.get("referrerId"));

      await db.runTransaction(async (tx) => {
        tx.update(invDoc.ref, {
          status: "active",
          activatedAt: admin.firestore.FieldValue.serverTimestamp(),
        });

        const referrerRef = db.collection("users").doc(referrerId);
        tx.update(referrerRef, {
          activeReferrals: admin.firestore.FieldValue.increment(1),
          points: admin.firestore.FieldValue.increment(50), // activation bonus
          updatedAt: admin.firestore.FieldValue.serverTimestamp(),
        });
      });

      await db.collection("events").add({
        type: "invite.activated",
        referrerId,
        inviteeId: uid,
        at: admin.firestore.FieldValue.serverTimestamp(),
        bonusPoints: 50,
      });

      logger.info("Invite activated & referrer rewarded", {
        referrerId,
        inviteeId: uid,
      });
    }
  }

  return { ok: true, activeScore: score, active };
});

// ======================================================
// 4) aggregateLeaderboard (scheduled, daily)
// Writes top100 by points to leaderboard/alltime
// ======================================================
export const aggregateLeaderboard = onSchedule("every 24 hours", async () => {
  const qs = await db
    .collection("users")
    .orderBy("points", "desc")
    .limit(100)
    .get();

  const top100 = qs.docs.map((d) => ({
    uid: d.id,
    displayName: d.get("displayName") ?? "",
    points: d.get("points") ?? 0,
    activeReferrals: d.get("activeReferrals") ?? 0,
  }));

  await db.collection("leaderboard").doc("alltime").set(
    {
      updatedAt: admin.firestore.FieldValue.serverTimestamp(),
      top100,
    },
    { merge: true }
  );

  logger.info("Leaderboard aggregated", { count: top100.length });
});
